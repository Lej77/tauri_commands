//! Provides procedural macros to the `tauri_commands` crate.

// Some imports are only used when certain features are enabled:
#![allow(unused_imports)]

macro_rules! const_cfg {
    // If else:
    (@parse {if cfg!($($cfg_if:tt)*) { $($then:tt)* } else $($else:tt)*} {  $({ $($so_far:tt)* })*  }) => {
        $( #[cfg(not(  $($so_far)*  ))] )*
        #[cfg($($cfg_if)*)]
        {
            $($then)*
        }
        const_cfg! {@parse {$($else)*} { $({ $($so_far)* })* { $($cfg_if)* } } }
    };
    // Final if clause:
    (@parse {if cfg!($($cfg_if:tt)*) { $($then:tt)* }} {  $({ $($so_far:tt)* })*  }) => {
        $( #[cfg(not(  $($so_far)*  ))] )*
        #[cfg($($cfg_if)*)]
        {
            $($then)*
        }
        // No else, so enforce that this is a statement:
        ;
    };
    // Final else clause:
    (@parse {{ $($else:tt)* }} { $({ $($so_far:tt)* })* }) => {
        $( #[cfg(not(  $($so_far)*  ))] )*
        {
            $($else)*
        }
    };
    (@parse {} { $($so_far:tt)* }) => { ::core::compile_error!("Macro input ended unexpectedly") };
    (@parse {$($fail:tt)*} { $($so_far:tt)* }) => {
        ::core::compile_error!(::core::concat!("Macro parsing failed, this text remained: ", ::core::stringify!($($fail)*)))
    };
    // Initial tokens:
    ($($tokens:tt)*) => {{
        const_cfg!{@parse {$($tokens)*} {}}
    }};
}

mod derives;
mod tauri_commands;

use proc_macro::TokenStream;
use proc_macro2::Ident;
use quote::{format_ident, quote};
use syn::{parse_macro_input, DeriveInput, Item, ItemFn, ItemTrait};

/// This macro can be used on a trait or on a trait implementation.
///
/// # Usage on trait
///
/// Use this on a trait definition to generate an implementation for WebAssembly
/// that calls the Tauri host.
///
/// ## Attribute arguments
///
/// - `crate` specifies the path to the `tauri_commands` crate inside a string.
/// - `wasm_client_impl_for` specifies the path to the type that wants an
///   implementation that works in WebAssembly.
/// - `method_attributes_to_keep` can be a list of string literals that specify
///   names of attributes that should be copied to the generated trait
///   implementation's methods (so not attributes on the trait itself).
///
/// # Usage on trait implementation
///
/// Use this on a trait implementation to generate commands for each function in
/// the implementation.
///
/// This will also generate a macro with the name
/// `with_commands_for_{trait_name}` where `trait_name` is the name of the trait
/// as specified in the `impl` block.
///
/// ## Attribute arguments
///
/// - `crate` specifies the path to the `tauri_commands` crate.
/// - `delegate_empty_methods_to` specifies another type that also implements
///   the trait, any methods with empty bodies will automatically call this
///   type's implementation instead.
///   - `delegate_args_using` specifies a macro that will be called with each
///     argument in a delegated function. This allows the macro to convert types
///     when necessary (when you have associated types that differ). The macro
///     should accept a string literal as its first argument then a comma (,)
///     followed by a single identifier. The macro should generate a new let
///     binding with the same name as the argument if changing the argument's
///     type is desired.
/// - `module_path` specifies the path to the module where the macro is invoked.
///   This is used when the `with_commands_for_{trait_name}` macro is generated
///   to refer to the right path.
/// - `rewrite_self` can be set to `false` to not rewrite `Self` type to the
///   concrete type for the generated command functions.
/// - `fix_async_command_results` can be set to `true` as a workaround for Tauri
///   requiring that all async commands return `Result` types.
/// - `method_attributes_to_keep` can be a list of string literals that specify
///   names of attributes that should be copied from methods in the trait
///   implementation to the generated Tauri command functions.
///
/// ## Example macro
///
/// The macro that is generated by the attribute will look something like this:
///
/// ```
/// macro_rules! with_commands_for_TraitName {
///     // Allow callback paths with leading colons:
///     ({$($callback:tt)*} $(then $( {$($callback_rest:tt)*} )then* )? $(with $($forward:tt)* )?) => {
///         $($callback)*! { $($( {$($callback_rest)*} )then* with)?  $(  $($forward)*  ,)?  command1, command2, command3  }
///     };
///     // Simpler syntax when leading colons aren't needed:
///     ($($callback:ident)::+ $(then $( $($callback_rest:ident)::* )then* )? $(with $($forward:tt)* )?) => {
///         $($callback)::*! { $($( $($callback_rest)::* )then* with)?  $(  $($forward)*  ,)?  command1, command2, command3  }
///     };
/// }
/// ```
#[proc_macro_attribute]
pub fn tauri_commands(args: TokenStream, mut item: TokenStream) -> TokenStream {
    // Parse attribute args:
    let mut cmd_attrs = tauri_commands::TauriCommandsAttributes::default();
    if !args.is_empty() {
        let args_parser = cmd_attrs.parser();
        parse_macro_input!(args with args_parser);
    }

    let (keep_original, output) = {
        let item = item.clone();
        cmd_attrs.expand(parse_macro_input!(item as Item))
    };
    let out = TokenStream::from(output);
    if keep_original {
        item.extend(out);
        item
    } else {
        out
    }
}

/// This derive macro just ensures the compiler understands that the `specta`,
/// `serde` and `tauri_type` attributes are allowed on a type.
#[proc_macro_derive(NoopSpectaType, attributes(specta, serde, tauri_type))]
pub fn allow_specta_type_attributes(_: TokenStream) -> TokenStream {
    TokenStream::new()
}

/// This derive macro just ensures the compiler understands that the `serde` and
/// `tauri_serde` attributes are allowed on a type.
#[proc_macro_derive(AllowSerde, attributes(serde, tauri_serde))]
pub fn allow_derive_attributes(_: TokenStream) -> TokenStream {
    TokenStream::new()
}

/// Implements `TauriSerialize` via `serde`'s derive macro.
#[allow(non_snake_case)]
#[proc_macro_attribute]
pub fn TauriSerialize(args: TokenStream, item: TokenStream) -> TokenStream {
    derives::DeriveInfo::TauriSerialize.parse_and_add_derives(args.into(), item)
}

/// Implements `TauriDeserialize` via `serde`'s derive macro.
#[allow(non_snake_case)]
#[proc_macro_attribute]
pub fn TauriDeserialize(args: TokenStream, item: TokenStream) -> TokenStream {
    derives::DeriveInfo::TauriDeserialize.parse_and_add_derives(args.into(), item)
}

/// Implements `TauriType` via `specta`'s derive macro.
#[allow(non_snake_case)]
#[proc_macro_attribute]
pub fn TauriType(args: TokenStream, item: TokenStream) -> TokenStream {
    derives::DeriveInfo::TauriType.parse_and_add_derives(args.into(), item)
}
